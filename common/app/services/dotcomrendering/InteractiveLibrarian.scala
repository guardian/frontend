package services.dotcomrendering

import common.GuLogging
import play.api.libs.ws.WSClient
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

import scala.concurrent._
import ExecutionContext.Implicits.global

import pagepresser.{InteractiveImmersiveHtmlCleaner}

/*

  Date: 05th July 2021
  Author: Pascal

  InteractiveLibrarian was introduced in July 2021 to support the migration of the rendering of interactives
  from frontend to DCR.

  The current main approach to this migration is that interactives created after 2021-06-23 (see the InteractivePicker
  in [applications]) are sent to DCR for rendering and those before that time will be served by a mix of DCR and the Interactive Librarian

  The Interactive Librarian offers functions to

    1. Store an "original" document from a live URL. Original means the
       full HTML document generated by frontend and sent to the user. This original document will actually be retrieved
       using an HTTP client

    2. "Clean" an original document by removing of elements from the dom tree that we do not which to keep in
       the "cleaned" version.

    3. Retrieve the cleaned version and use it in full or as the basis of what be sent to the client.

  Which proportion of the past interactives will be served by the Librarian is still to be determined.

  In the "worst" case scenario all past interactives will be served from their stored version by the Librarian. In the
  best case scenario they will all be renderable by DCR and in fact the InteractiveLibrarian will be removed from the
  code. It is likely that reality will be a situation where most past interactives are rendered by DCR and a few are
  rendered from their pressed version using the Librarian.

  Update: 23th August 2021
  Documentation covering Librarian operations has been added to frontend.
  See [frontend]/docs/06-features-and-components/04-The-Interactive-Librarian

 */

object InteractiveLibrarian extends GuLogging {

  // ----------------------------------------------------------
  // Basic S3 I/O

  private def commitOriginalDocumentToS3(s3path: String, document: String): (Boolean, String) = {
    try {
      // On local bucket is: aws-frontend-archive-code-originals
      services.S3ArchiveOriginals.putPublic(s3path, document, "text/html")
      (true, "")
    } catch {
      case e: Exception => (false, e.getMessage)
    }
  }

  private def commitCleanedDocumentToS3(s3path: String, document: String): (Boolean, String) = {
    try {
      // On local bucket is: aws-frontend-archive-code-originals
      services.S3Archive.putPublic(s3path, document, "text/html")
      (true, "")
    } catch {
      case e: Exception => (false, e.getMessage)
    }
  }

  private def retrieveOriginalDocumentFromS3(s3path: String): Option[String] = {
    services.S3ArchiveOriginals.get(s3path)
  }

  private def retrieveCleanedDocumentFromS3(s3path: String): Option[String] = {
    services.S3Archive.get(s3path)
  }

  // ----------------------------------------------------------
  // Cleaning

  def cleanOriginalDocument(document: String): String = {
    val parsedDoc = Jsoup.parse(document)

    // In the clean function below we hardcode argument convertToHttps to false.
    // Interactive immersives use http links to, for example, ensure svgs load,
    // so we don't want to force these links to be relative.
    val doc: Document = InteractiveImmersiveHtmlCleaner.clean(parsedDoc, false)
    doc.toString
  }

  def applyCleaning(s3path: String): Boolean = {
    log.info(s"Interactive Librarian. Apply cleaning. s3path: ${s3path}")
    // This function takes a s3 path pointing at an original document (meaning something pressed from live contents)
    // and writes the cleaned version.
    retrieveOriginalDocumentFromS3(s3path) match {
      case Some(document) => {
        val cleaned = cleanOriginalDocument(document)
        val status = commitCleanedDocumentToS3(s3path, cleaned)
        status._1 // We project to the first component and ignore the possible error string for the moment
      }
      case None => false
    }
  }

  // ----------------------------------------------------------
  // Operations

  def pressLiveContents(wsClient: WSClient, path: String): Future[String] = {
    // 1. Takes a path ( books/ng-interactive/2021/mar/05/this-months-best-paperbacks-michelle-obama-jan-morris-and-more )
    // 2. Queries the live contents ( https://www.theguardian.com/books/ng-interactive/2021/mar/05/this-months-best-paperbacks-michelle-obama-jan-morris-and-more )
    // 3. Stores the document at S3 path ( www.theguardian.com/books/ng-interactive/2021/mar/05/this-months-best-paperbacks-michelle-obama-jan-morris-and-more )
    log.info(s"Interactive Librarian. Pressing path: ${path}")
    val liveUrl = s"https://www.theguardian.com/${path}?dcr=false"
    val s3path = s"www.theguardian.com/${path}"
    val wsRequest = wsClient.url(liveUrl)
    wsRequest.get().flatMap { response =>
      response.status match {
        case 200 => {
          val liveDocument = response.body
          val (ok, errorMsg) = commitOriginalDocumentToS3(s3path, liveDocument)
          if (ok) {
            Future.successful(
              s"Live Contents S3 Pressing. Operation successful. Path: ${path}. Length: ${liveDocument.length}",
            )
          } else {
            Future.failed[String](
              new Throwable(s"Live Contents S3 Pressing. Operation not successful. Path: ${path}. Error: ${errorMsg}"),
            )
          }
        }
        case non200 =>
          Future.failed[String](new Throwable(s"Unexpected response from ${wsRequest.uri}, status code: $non200"))
      }
    }
  }

  def readCleanWrite(path: String): (Boolean, String) = {

    // The first component of the return value says whether the operation completed successfully,
    // in the negative case the string indicates what happened.

    val s3path = s"www.theguardian.com/${path}"
    retrieveOriginalDocumentFromS3(s3path).fold(
      (false, s"could not retrieve the original document at ${s3path}"),
    )(document => commitCleanedDocumentToS3(s3path, cleanOriginalDocument(document)))
  }

  def getDocumentFromS3(path: String): Option[String] = {
    val s3path = s"www.theguardian.com/${path}"
    retrieveCleanedDocumentFromS3(s3path)
  }
}
