#!/usr/bin/env node
/* eslint-disable no-console */

const path = require('path');
const fs = require('fs');
const execa = require('execa');
const chalk = require('chalk');

const fixAndStage = (jsFiles, localDir) =>
    execa('eslint', ['--fix', ...jsFiles], {
        stdio: 'inherit',
        localDir,
    }).then(() =>
        execa('git', ['add', ...jsFiles], {
            stdio: 'inherit',
        })
    );

const fixStagedIn = (stagedFiles, location) => {
    const locations = {
        static: {
            filter: file => file.startsWith('static') && file.endsWith('.js'),
            localDir: process.cwd(),
        },
        ui: {
            filter: file =>
                file.startsWith('ui') &&
                (file.endsWith('.js') || file.endsWith('.jsx')),
            localDir: 'ui',
        },
    };
    const jsFiles = stagedFiles
        .filter(locations[location].filter)
        .filter(file => fs.existsSync(file));

    if (jsFiles.length) {
        return fixAndStage(jsFiles, locations[location].localDir).then(
            () => stagedFiles
        );
    }

    return Promise.resolve(stagedFiles);
};

execa
    .stdout('git', ['diff', '--name-only', '--cached', '--diff-filter=AM'])
    .then(staged => staged.split('\n'))
    // lint and commit any lint fixes
    .then(staged =>
        fixStagedIn(staged, 'static').then(() => fixStagedIn(staged, 'ui'))
    )
    // make sure yarn.lock is committed
    .then(staged => {
        if (
            staged.some(file => file === 'package.json') &&
            !staged.some(file => file === 'yarn.lock')
        ) {
            return Promise.reject(
                `${chalk.red(
                    `${chalk.underline(
                        'package.json'
                    )} has changed but ${chalk.underline(
                        'yarn.lock'
                    )} is not included in this commit.`
                )}\n${chalk.dim(
                    `If this is intentional, commit this change with --no-verify.`
                )}`
            );
        }
        return staged;
    })
    // make sure docs TOC stays up to date
    .then(staged => {
        if (staged.some(file => file.includes('docs/'))) {
            const docs = path.resolve('docs');
            const readme = path.resolve(docs, 'README.md');
            return execa(path.resolve(docs, 'generate-toc.sh'), ['>', readme], {
                stdio: 'inherit',
            })
                .then(() => execa.sync('git', ['add', readme]))
                .then(() => staged);
        }
        return staged;
    })
    .catch(e => {
        console.log(`\n${e}\n`);
        process.exit(1);
    });
